## 아이템15. 클래스와 멤버의 접근 권한을 최소화하라
- 모든 클래스와 멤버의 접근성을 가능한 한 좁혀야 한다.(항상 가장 낮은 접근 수준을 부여해야 한다)
- 톱레벨 클래스와 인터페이스에 부여할 수 있는 접근 수준은 default(package-private)과 public 두가지다. 
- public으로 선언한다면 공개 API가 되므로 하위 호환을 위해 영원히 관리해줘야만 한다.

### 접근제어자의 접근 범위
|         |   같은 클래스  | 같은 패키지 | 같은 패키지의 상속 클래스 | 다른 패키지의 상속 클래스 | 전체 클래스 |
| --- | :---: | :---: | :---:  |  :---:  |  :---:  |
| public  |  O | O | O | O | O |
| protected | O | O | O | O |  |
| package-private | O | O | O | |  | 
| private | O | |  |  |  |


- 클래스의 공개 API를 세심히 설계한 후 그 외의 모든 멤버는 private으로 만든다.
- 이후 오직 같은 패키지의 다른 클래스가 접근해야 하는 멤버에 한하여 package-private으로 풀어준다.
- private과 package-private 멤버느 모두 해당 클래스의 구현에 해당하므로 보통 공개 API에 영향을 주지 않는다. (단 Serializable을 구현한 클래스에서는 그 필드들도 의도치 않게 공개 API가 될 수도 있다.)
- protected 멤버의 수는 적을수록 좋다. (공개API이기 때문)
- 상위 클래스의 메서드를 재정의할 때는 그 접근 수준을 상위 클래스에서보다 좁게 설정할 수 없다.( 이 제약은 상위 클래스의 인스턴스는 하위 클래스의 인스턴스로 대체해 사용할 수 있어야 한다는 규칙 때문, 리스코프 치환 원칙)
- public 클래스의 인스턴스 필드는 되도록 public이 아니어야 한다.
  - 불변식을 보장받지 못하기 때문
  - 스레드 안전하지 않기 때문
- 상수라면 public static final 필드로 공개해도 좋다.
  - 기본 타입 값이나 불변 객체를 참조해야 한다. 
  - public static final 배열 필드를 두거나 이 필드를 반환하는 접근자 메서드를 제공해서는 안된다.

가변 객체인 배열을 사용했을경우 해결책은 두가지.
```
public static final Thing[] VALUES = {...};
```

#### 1) private으로 만들고, public 불변 리스트를 추가
```
private static final Thing[] PRIVATE_VALUES = { ... };
public static final List<Thing> VALUES = Collections.unmodifiableList(Arrays.asList(PRIVATE_VALUES));
```

#### 2) private으로 만들고, 그 복사본을 반환하는 public 메서드를 추가(방어적 복사)
```
private static final Thing[] PRIVATE_VALUES = { ... };
public static final Thing[] values(){
  return PRIVATE_VALUES.clone();
}
```


## 아이템 16. public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라

## 아이템 17. 변경 가능성을 최소화하라
- 불변 클래스란 인스턴스의 내부 값을 수정할 수 없는 클래스다. 불변 인스턴스에 간직된 정보는 객체가 파괴되는 순간까지 절대 달라지지 않는다.
- ex) String, 기본 타입의 박싱된 클래스들, BigInteger, BigDecimal

### 불변 클래스의 5가지 규칙
- 객체의 상태를 변경하는 메서드를 제공하지 않는다.
- 클래스를 확장할 수 없도록 한다. (상속 x)
- 모든 필드는 final로 선언한다.
- 모든 필드는 private으로 선언한다.
- 자신 외에는 내부의 가변 객체(컴포넌트)에 접근할 수 없도록 한다.


### 특징
- 불변 객체는 근본적으로 스레드 안전하여 따로 동기화할 필요 없다. 불변 객체에 대해서는 그 어떤 스레드도 다른 스레드에 영향을 줄 수 없으니 불변 객체는 안심하고 공유할 수 있다. 따라서 불변 클래스라면 한번 만든 인스턴스를 최대한 재활용하기를 권한다.
- 불변 클래스는 자주 사용되는 인스턴스를 캐싱하여 같은 인스턴스를 중복 생성하지 않게 해주는 정적 팩터리를 제공할 수 있다. 이런 정적 팩터리를 사용하면 여러 클라이언트가 인스턴스를 공유하여 메모리 사용량과 가비지 컬렉션 비용이 줄어든다.
- 불변 객체를 자유롭게 공유할 수 있다는 점은 방어적 복사도 필요없다. 그러니 불변 클래스는 clone 메서드나 복사 생성자를 제공하지 않는게 좋다. String 클래스의 복사 생성자는 잘못 만들어 졌다.
- 불변 객체는 자유롭게 공유할 수 있음은 물론 불변 객체끼리는 내부 데이터를 공유할 수 있다.

### 단점
- 불변 객체를 잘못 만들었다면 객체를 다시 생성해야 한다. (필드의 값을 잘못 넣었다면)
  #### 해결법
  - 다단계 연산을 기본으로 제공한다. 이부분 이해가 안됨.

### 자신을 상속하지 못하게 하는 방법
- final 클래스로 선언
- 모든 생성자를 private 혹은 package-private으로 만들고 public 정적 팩터리를 제공 (유연한 방법)
- 정적 팩터리 방식은 다수의 구현 클래스를 활용한 유연성을 제공하고, 이에 더해 객체 캐싱 기능을 추가해 성능을 끌어올릴 수도 있다.

#### 정적 팩터리 방식 예제
```
public class Complex{
  private final double re;
  private final double im;
  
  private Complex(double re, double im){
    this.re = re;
    this.im = im;
  }
  
  public static Complex valueOf(double re, double im){
    return  new Complex(re, im);
  }
  ...  생략
}

```

- 어떤 불변 클래스는 계산 비용이 큰 값을 나중에 계산하여 final이 아닌 필드에 캐시해놓기도 한다. 똑같은 값을 다시 요청하면 캐시해둔 값을 반환하여 계산 비용을 절감하는 것이다.
- 클래스는 꼭 필요한 경우가 아니라면 불변이어야 한다. getter가 있다고 해서 무조건 setter를 만들지 말자.
- 무거운 값 객체(ex)String, BigInteger)를 불변으로 만들 수 있는지 고심해야 한다. 성능 떄문에 어쩔수없다면 불변 클래스와 쌍을 이루는 가변 동반 클래스를 public 클래스로 제공하도록 하자.
- 불변으로 만들 수 없는 클래스라도 변경할 수 있는 부분을 최소한으로 줄이자. 객체가 가질 수 있는 상태의 수를 줄이면 그 객체를 예측하기 쉬워지고 오류가 생길 가능성도 줄어든다. 꼭 변경해야 할 필드를 뺀 나머지 모두는 final로 선언하자. 다른 합당한 이유가 없다면 모든 필드는 private final이어야 한다.
- 생성자와 정적 패터리 외에는 그 어떤 초기화 메서드도 public으로 제공해서는 안된다. 객체를 재활용할 목적으로 상태를 다시 초기화하는 메서드도 안된다. 복잡성만 커지고 성능 이점은 거의 없다.

## 아이템 18. 상속보다는 컴포지션을 사용하라
- 상속은 캡슐화를 깨뜨린다. 상위 클래스가 어떻게 구현되느냐에 따라 하위 클래스의 동작에 이상이 생길 수 있다. 상위 클래스는 릴리스마다 내부 구현이 달라질 수 있으며, 그 여파로 코드 한 줄 건드리지 않은 하위 클래스가 오동작할 수 있다는 말이다.

### 상속시 문제점
- 상위클래스의 메서드 동작방식을 제대로 이해하지 못한 상황에서 하위클래스가 상위 클래스의 메서드 재정의시 문제가 발생할 수 있다.
- 다음 릴리스에서 상위 클래스가 새로운 메서드를 추가할 경우


### 해결법
- 기존 클래스를 확장하는 대신, 새로운 클래스를 만들고 private 필드로 기존 클래스의 인스턴스를 참조하게 한다. 기존 클래스가 새로운 클래스의 구성요소로 쓰인다는 뜻에서 이러한 설계를 컴포지션이라 한다.
- 새 클래스의 인스턴스 메서드들은 기존 클래스의 대응하는 메서드를 호출해 그 결과를 반환한다.
- 그 결과 새로운 클래스는 기존 클래스의 내부 구현 방식의 영향에서 벗어나며 심지어 기존 클래스에 새로운 메서드가 추가되더라도 전혀 영향을 받지 않는다.

- 래퍼클래스
  - Set인터페이스의 기존 기능에 계측기능(getAddCount)를 더함.
```
public class InstrumentedSet<E> extends ForwardingSet<E>{
  private int addCount = 0;
  
  public InstrumentedSet(Set<E> s){
    super(s);
  }
  
  @Override public boolean add(E e){
    addCount ++;
    return super.add(e);
  }
  
  ... 생략
  
  public int getAddCount(){
    return addCount;
  }
}

```

- 전달클래스

```
public class ForwardingSet<E> implements Set<E> {

  private final Set<E> s;
  public ForwardingSet(Set<E> s) {this. s = s;}

  public void clear() {s.clear(); } // Set 구현체의 전달메서드
  public boolean contains(Object o) { return s.contains(o); } // Set 구현체의 전달메서드
  ... 생략
}

```

- 클라이언트에서 호출
  - 다른 Set 인스턴스를 감싸고(wrap)있다는 뜻에서 InstrumentedSet 같은 클래스를 래퍼 클래스라 하며, 다른 Set에 계측 기능을 덧씌운다는 뜻에서 데코레이터 패턴이라고 한다.
```
  Set<Instant> times = new InstrumentedSet<>(new TreeSet<>(cmp));
  Set<E> s = new InstrumentedSet<>(new HashSet<>(INIT_CAPACITY));
```


### 상속을 사용해야 할 때는 언제?
- 상속은 반드시 하위 클래스가 상위 클래스의 '진짜' 하위 타입인 상황에서만 쓰여야 한다. 다르게 말하면 클래스 B가 클래스 A와 is-a 관게일 때만 클래스 A를 상속해야 한다. 즉 클래스 A를 상속하는 클래스 B를 작성하려 한다면 "B가 정말 A인가?"에 대한 질문에 "네"라고 답할 수 있어야 한다. (거의 없음)
- 상속을 꼭 해야할 때 자문해야 할 질문들
  - 확장하려는 클래스의 API에 아무런 결함이 없는가?
  - 결함이 있다면 이 결함이 여러분 클래스의 API까지 전파돼도 괜찮은가?


## 아이템 19. 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라


## 아이템 20. 추상 클래스보다는 인터페이스를 우선하라
- 자바가 제공하는 다중 구현 메커니즘은 인터페이스와 추상클래스이다.
- 자바 8부터 인터페이스도 디폴트 메서드를 제공할 수 있게 되어 두 메커니즘 모두 인스턴스 메서드를 구현 형태로 제공할 수 있다.
- 둘의 가장 큰 차이는 추상 클래스가 정의한 타입을 구현하는 클래스는 반드시 추상 클래스의 하위 클래스가 되어야 한다는 점이다. (자바는 단일 상속, 새로운 타입을 정의하는데 커다란 제약)
- 반면 인터페이스가 선언한 메서드를 모두 정의하고 그 일반 규약을 잘 지킨 클래스라면 다른 어떤 클래스를 상속했든 같은 타입으로 취급된다.

### 인터페이스의 장점
- 기존 구현된 클래스에도 손쉽게 새로운 인터페이스를 구현해넣을수 있다. 
  - 자바 플랫폼에서도 Comparable, Iterable, AutoCloseable 인터페이스가 새로 추가됐을 때 표준 라이브러리의 수많은 기존 클래스가 이 인터페이스들을 구현한 채 릴리스됐다.
  - 반면 기존 클래스 위에 새로운 추상 클래스를 끼워넣기는 어려운게 일반적이다. 만약 끼워넣더라도 새로 추가된 추상 클래스의 모든 자손이 이를 상속하게 되는 것이다.
- 인터페이스는 믹스인(mixin) 정의에 안성맞춤이다.
  - 믹스인이란 클래스가 구현할 수 있는 타입으로, 믹스인을 구현한 클래스에 원래의 주된 타입 외에도 특정 선택적 행위를 제공한다는 선언하는 효과를 준다.
  - 예를 들어 Comparable은 자신을 구현한 클래스의 인스턴스들끼리는 순서를 정할 수 있다고 선언하는 믹스인 인터페이스다.
- 인터페이스는 계층구조가 없는 타입 프레임워크를 만들 수 있다.

### 인터페이스의 제약
- 많은 인터페이스가 equals와 hashCode 같은 Object 메서드를 정의하고 있지만, 이들은 디폴트 메서드로 제공해서는 안된다.
- 인터페이스는 인스턴스 필드를 가질 수 없다.
- public이 아닌 정적 멤버를 가질 수 없다.
- 여러분이 만들지 않은 인터페이스에는 디폴트 메서드를 추가할 수 없다.

### 인터페이스의 활용
- 인터페이스의 메서드 중 구현 방법이 명백한 것이 있다면 그 구현을 디폴트 메서드로 제공해 개발자의 일감을 덜어줄 수 있다.
- 인터페이스와 추상 골격 구현 클래스를 함께 제공하는 식으로 인터페이스와 추상 클래스의 장점을 모두 취하는 방법도 있다.
  - 인터페이스에 걸려 있는 구현상의 제약 때문에 골격 구현을 추상 클래스로 제공하는 경우다.
  - ex) AbstractCollection, AbstractSet, AbstractList, AbstractMap
  


