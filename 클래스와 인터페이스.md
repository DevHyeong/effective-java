## 아이템15. 클래스와 멤버의 접근 권한을 최소화하라
- 모든 클래스와 멤버의 접근성을 가능한 한 좁혀야 한다.(항상 가장 낮은 접근 수준을 부여해야 한다)
- 톱레벨 클래스와 인터페이스에 부여할 수 있는 접근 수준은 default(package-private)과 public 두가지다. 
- public으로 선언한다면 공개 API가 되므로 하위 호환을 위해 영원히 관리해줘야만 한다.

### 접근제어자의 접근 범위
|         |   같은 클래스  | 같은 패키지 | 같은 패키지의 상속 클래스 | 다른 패키지의 상속 클래스 | 전체 클래스 |
| --- | :---: | :---: | :---:  |  :---:  |  :---:  |
| public  |  O | O | O | O | O |
| protected | O | O | O | O |  |
| package-private | O | O | O | |  | 
| private | O | |  |  |  |


- 클래스의 공개 API를 세심히 설계한 후 그 외의 모든 멤버는 private으로 만든다.
- 이후 오직 같은 패키지의 다른 클래스가 접근해야 하는 멤버에 한하여 package-private으로 풀어준다.
- private과 package-private 멤버느 모두 해당 클래스의 구현에 해당하므로 보통 공개 API에 영향을 주지 않는다. (단 Serializable을 구현한 클래스에서는 그 필드들도 의도치 않게 공개 API가 될 수도 있다.)
- protected 멤버의 수는 적을수록 좋다. (공개API이기 때문)
- 상위 클래스의 메서드를 재정의할 때는 그 접근 수준을 상위 클래스에서보다 좁게 설정할 수 없다.( 이 제약은 상위 클래스의 인스턴스는 하위 클래스의 인스턴스로 대체해 사용할 수 있어야 한다는 규칙 때문, 리스코프 치환 원칙)
- public 클래스의 인스턴스 필드는 되도록 public이 아니어야 한다.
  - 불변식을 보장받지 못하기 때문
  - 스레드 안전하지 않기 때문
- 상수라면 public static final 필드로 공개해도 좋다.
  - 기본 타입 값이나 불변 객체를 참조해야 한다. 
  - public static final 배열 필드를 두거나 이 필드를 반환하는 접근자 메서드를 제공해서는 안된다.

가변 객체인 배열을 사용했을경우 해결책은 두가지.
```
public static final Thing[] VALUES = {...};
```

#### 1) private으로 만들고, public 불변 리스트를 추가
```
private static final Thing[] PRIVATE_VALUES = { ... };
public static final List<Thing> VALUES = Collections.unmodifiableList(Arrays.asList(PRIVATE_VALUES));
```

#### 2) private으로 만들고, 그 복사본을 반환하는 public 메서드를 추가(방어적 복사)
```
private static final Thing[] PRIVATE_VALUES = { ... };
public static final Thing[] values(){
  return PRIVATE_VALUES.clone();
}
```


## 아이템 16. public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라

## 아이템 17. 변경 가능성을 최소화하라
- 불변 클래스란 인스턴스의 내부 값을 수정할 수 없는 클래스다. 불변 인스턴스에 간직된 정보는 객체가 파괴되는 순간까지 절대 달라지지 않는다.
- ex) String, 기본 타입의 박싱된 클래스들, BigInteger, BigDecimal

### 불변 클래스의 5가지 규칙
- 객체의 상태를 변경하는 메서드를 제공하지 않는다.
- 클래스를 확장할 수 없도록 한다. (상속 x)
- 모든 필드는 final로 선언한다.
- 모든 필드는 private으로 선언한다.
- 자신 외에는 내부의 가변 객체(컴포넌트)에 접근할 수 없도록 한다.


### 특징
- 불변 객체는 근본적으로 스레드 안전하여 따로 동기화할 필요 없다. 불변 객체에 대해서는 그 어떤 스레드도 다른 스레드에 영향을 줄 수 없으니 불변 객체는 안심하고 공유할 수 있다. 따라서 불변 클래스라면 한번 만든 인스턴스를 최대한 재활용하기를 권한다.
- 불변 클래스는 자주 사용되는 인스턴스를 캐싱하여 같은 인스턴스를 중복 생성하지 않게 해주는 정적 팩터리를 제공할 수 있다. 이런 정적 팩터리를 사용하면 여러 클라이언트가 인스턴스를 공유하여 메모리 사용량과 가비지 컬렉션 비용이 줄어든다.
- 불변 객체를 자유롭게 공유할 수 있다는 점은 방어적 복사도 필요없다. 그러니 불변 클래스는 clone 메서드나 복사 생성자를 제공하지 않는게 좋다. String 클래스의 복사 생성자는 잘못 만들어 졌다.
- 불변 객체는 자유롭게 공유할 수 있음은 물론 불변 객체끼리는 내부 데이터를 공유할 수 있다.

### 단점
- 불변 객체를 잘못 만들었다면 객체를 다시 생성해야 한다. (필드의 값을 잘못 넣었다면)
  #### 해결법
  - 다단계 연산을 기본으로 제공한다. 이부분 이해가 안됨.

### 자신을 상속하지 못하게 하는 방법
- final 클래스로 선언
- 모든 생성자를 private 혹은 package-private으로 만들고 public 정적 팩터리를 제공 (유연한 방법)
- 정적 팩터리 방식은 다수의 구현 클래스를 활용한 유연성을 제공하고, 이에 더해 객체 캐싱 기능을 추가해 성능을 끌어올릴 수도 있다.

#### 정적 팩터리 방식 예제
```
public class Complex{
  private final double re;
  private final double im;
  
  private Complex(double re, double im){
    this.re = re;
    this.im = im;
  }
  
  public static Complex valueOf(double re, double im){
    return  new Complex(re, im);
  }
  ... 생략
}

```

- 어떤 불변 클래스는 계산 비용이 큰 값을 나중에 계산하여 final이 아닌 필드에 캐시해놓기도 한다. 똑같은 값을 다시 요청하면 캐시해둔 값을 반환하여 계산 비용을 절감하는 것이다.
- 클래스는 꼭 필요한 경우가 아니라면 불변이어야 한다. getter가 있다고 해서 무조건 setter를 만들지 말자.
- 무거운 값 객체(ex)String, BigInteger)를 불변으로 만들 수 있는지 고심해야 한다. 성능 떄문에 어쩔수없다면 불변 클래스와 쌍을 이루는 가변 동반 클래스를 public 클래스로 제공하도록 하자.
- 불변으로 만들 수 없는 클래스라도 변경할 수 있는 부분을 최소한으로 줄이자. 객체가 가질 수 있는 상태의 수를 줄이면 그 객체를 예측하기 쉬워지고 오류가 생길 가능성도 줄어든다. 꼭 변경해야 할 필드를 뺀 나머지 모두는 final로 선언하자. 다른 합당한 이유가 없다면 모든 필드는 private final이어야 한다.
- 생성자와 정적 패터리 외에는 그 어떤 초기화 메서드도 public으로 제공해서는 안된다. 객체를 재활용할 목적으로 상태를 다시 초기화하는 메서드도 안된다. 복잡성만 커지고 성능 이점은 거의 없다.

## 아이템 18. 상속보다는 컴포지션을 사용하라
- 상속은 캡슐화를 깨뜨린다. 상위 클래스가 어떻게 구현되느냐에 따라 하위 클래스의 동작에 이상이 생길 수 있다. 상위 클래스는 릴리스마다 내부 구현이 달라질 수 있으며, 그 여파로 코드 한 줄 건드리지 않은 하위 클래스가 오동작할 수 있다는 말이다.
- 
